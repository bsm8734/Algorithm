# Algorithm

##### 목차
- [기본](#기본)
- [문자열](#문자열)
- [vector](#vector)
- [정렬](#정렬)
- [Queue, PQ, Heap](#Queue,-PQ,-Heap)
- [Stack](#Stack)
- [Deque](#Deque)
- map
- set
- 구현
- 그리디
- 이분탐색
- 그래프
- 해시
- 다이나믹 프로그래밍
- 알고리즘 심화
- 수학적 사고력?
---

# 기본
##### 입출력  
  `#include <iostream>`: `cin, cout` 표준 입출력 함수를 사용하기 위한 헤더  
  `using namespace std;`: `std::` 생략하기 위해서 사용
  `#define _CRT_SECURE_NO_WARNINGS`: scanf 보안 경고로 인한 컴파일 에러 방지

##### 포인터
  - & : 실제로 잡혀있는 메모리 위치를 가리킴
  - \* : 포인터

  ```c
    int *ptr; // 선언
    int *ptr1 = nullptr; // 초기화
    int* ptr = NULL;

    int num = 10;
    int *ptr = &num;
    cout << *ptr << '\n'; // 10
    cout << ptr << '\n';  // 값의 주소
    cout << &ptr << '\n'; // 포인터의 주소

    // int* ptr = 10; // 오류, 값을 포인터에 담을 수 없음
  	int num = 10;
  	int* ptr = &num;
  	cout << *ptr << '\n'; // 10
  	cout << ptr << '\n';  // 값의 주소
  	cout << &ptr << '\n'; // 포인터의 주소

  	char s1[] = "HelloMWorld";
  	// char* ptr = strchr(s1, 'W');
  	if (ptr != NULL) {
  		cout << *ptr << endl;	  // W
  		cout << ptr << endl;	   // World
  		cout << &ptr << endl;	  // 주소
  		// printf("%c, %s\n", *ptr, ptr); // W, World
  	}
  	cout << strchr(s1, 'M');
    // 주의: ptr은 쓰레기 값으로 초기화되며, 그 위치에 값을 넣는 것은 위험함
    int *ptr;
    *ptr = 100;
  ```

  - [포인터 변수의 크기]는 [포인터 변수가 가리키는 변수의 데이터형]과는 관계없이 __4Byte__로 동일  
  - 단순히 "주소가 가리키는 값이 int형 변수다" 라는 것을 알려주기 위함  
  - 포인터 역참조  
    자료형 없이 *ptr 호출하면 주소를 역으로 참조하여 그 주소가 가지고 있는 실제 값을 가져옴

##### 자료형
  - 형변환
    ```c
      // =========================== string & numbers ========================= //
      // int to string
      string str = to_string(num);

      // string to int
      int num = stoi(str);
    ```
    ```c
      // =========================== string Tips! ========================= //
      // string with others
      stoi(str) // string to int
      stol(str) // string to long int

      // 다른 파라미터 없이 사용하면 소수아래자리에 0을 채워, (점 포함) 8 글자 출력
      stof(str) // stirng to float
      stod(str) // string to double

      string str_d = "2.11";
      cout << stod(str_d) << '\n'; // 2.110000

      // 받고자하는 형식이 아닌 문자 나오면 바로 자름
      string str = "33 3Hello00World";
    	int num = stoi(str);
    	cout << num << '\n'; // 33

      /* 원하는 형식으로 진수 설정 가능 */
      //string binary(2) -> int
      cout << stoi("1110", nullptr, 2) << endl; // 14

      //string oct(8) -> int
      cout << stoi("014", nullptr, 8) << endl; // 12

      //string hex(16) -> int
      cout << stoi("0x14", nullptr, 16) << endl; // 20
    ```
    ```c
      // ================================ char* =============================== //
      // char* to int
      int num = atoi(cStr);

      // char* to string
      string str = cStr;

      // string to char*
      char* cStr = str.c_str();
    ```

  - typedef
    ```c
      #include <string.h>    // strcpy 함수가 선언된 헤더 파일

      typedef 자료형 별칭;
      typedef long long int ll;

      typedef struct _Student {   // 구조체 이름: _Student
        int age;
        string name;
      } Student;                  // 구조체 별칭: Student

      Student s1;                  // 구조체 별칭 Student으로 변수 선언
      strcpy(s1.name, "홍길동");   // . 으로 구조체 멤버에 접근하여 값 할당
      s1.age = 30;
    ```

  - 표현가능 범위
    + 1byte = 8bit (*2의 8제곱 표현가능*) `char`
    + 4byte = 4x8bit = 32bit (*2의 32제곱 표현가능*) `int, long`
    + 8byte = 8x8bit = 64bit (*2의 64제곱 표현가능*) `long long`, `long long int`

    > K = 2^10 = 10^3  
    M = 2^20 = 10^6  
    G = 2^30 = 10^9  

##### pair
  ```c
  // 선언
  pair<int, int> p1;
  pair<int, string> p2 = make_pair(1, "bsm");

  // 접근
  cout << p2.first << ' ' << p2.second << '\n';   // 1 bsm

  // 활용
  vector<pair<int, string> > v;

  v.push_back({1, "hello"});    
  v.push_back(pair<int, string>(3, "world"));

  vector<pair<int, string> >::iterator iter;
  for(iter = v.begin(); iter != v.end(); iter++){
      cout << "[" << iter->first << "," << iter->second << "]" << endl;
  }

  ```

##### cmath 헤더
  ```c
    #include <cmath>

    // 원하는 개수만큼의 소수점 출력
    cout<< fixed;
    cout.precision(1); // 소수점 1자리까지 표현 (반올림)

    cout.setf(ios::fixed);    // 설정 (= cout << fixed;)
    cout.unsetf(ios::fixed);  // 해제

    // 반올림: round 함수
    round(3.2); // 3
    round(3.7); // 4
    round(-3.2); // -3
    round(-3.7); // -4

    // 올림,내림: ceil, floor 함수
    ceil(4.2);  // 5
    floor(4.2); // 4

    // 버림: trunk 함수
    trunk(3.2); // 3
    trunk(3.7); // 3
    trunk(-3.2); // -3

    trunk(-3.7); // -3
    floor(-3.7); // -4
  ```

##### algorithm 헤더
  - min, max
    ```c
      min(a, b) // 더 작은 값 반환
      max(a, b) // 더 큰 값 반환
    ```

    <details>
    <summary>min, max 재정의하여 클래스 비교 하기</summary>
    <div markdown="2">

    ```c
      // min, max를 사용하여 클래스를 비교 가능
      class Animal {
        private:
            int age;
            int legs;
        public:
            Animal(int _age, int _legs) : age(_age), legs(_legs) {};    //생성자

            //나이가 적은지 확인하고,
            //나이가 같다면 다리개수가 적은지 판단.
            bool operator<(const Animal& _animal) const
            {
                if (age != _animal.age)
                    return age < _animal.age;
                return legs < _animal.legs;
            }

            // cout 출력을 위한 "<<" 재정의.
            friend ostream& operator<<(ostream& _os, const Animal& _animal);
      };
      // cout 출력을 위한 "<<" 재정의.
      ostream& operator<<(ostream& _os, const Animal& _animal) {
          _os << _animal.age << '/' << _animal.legs;
          return _os;
      }

      Animal cat1(10, 4);
      Animal cat2(20, 4);
      cout << min(cat1, cat2) << '\n'; // 10/4
      cout << max(cat1, cat2) << '\n'; // 20/4
    ```
    </div>
    </details>

    <details>
    <summary>반복문을 사용하여 쉽게 min, max값 구하기</summary>
    <div markdown="2">

    ```c
      //min, max를 비교하기 위해 맨 앞 요소 저장.
      int smallest = v[0];
      int largest = v[0];

      for (int i = 1; i < len; ++i)
      {
          smallest = min(smallest, v[i]);   //작은 값을 다시 smallest에 대입
          largest = max(largest, v[i]);     //큰 값을 다시 largest에 대입
      }
    ```
    </div>
    </details>  

##### 반복문
  ```c
  // 범위기반 반복문: 배열, vector
  int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  for (int elem : arr)
    cout << elem << " ";

  for (auto elem : arr) {
    elem += 100; // 기존 데이터가 변경되지않음 // 이 줄은 실행되지않는 것과 같음
    cout << elem << " ";
  }
  for(int& elem : arr) {
    elem += 1;    // 기존 arr 데이터가 변경됨 // reference로 접근  
    cout << elem << endl;
  }

  // iterator -> string, vector, list 가능 (반복자 존재) // queue, stack (X)
  for(vector<int>::iterator iter = v.begin(); iter != v.end(); ++iter){
    *iter += 10; // 값 변경 // 포인터이므로 주소에 접근하여 값을 가져오거나 쓸 수 있음
    cout << *iter << '\n';
  }

  // auto 사용법
  // vector<string>::iterator = v.begin(); 와 같음
  auto it = v.begin();
  for (; it != v.end(); ++it)
  {
      cout << *it << '\n';
  }
  ```

---

# 문자열
`#include <string>`: 기본 제공하는 자료형이 아닌 string 객체를 사용하기 위한 헤더

##### 선언
  ```c
  string str1 = "Hello";
  string str2("Hello");

  string str3;
  str3.assign("12345678");

  // 동적할당
  string *pstr = new string("Hello");
  delete pstr;
  ```

##### append
  ```c
  string str1 = "hello";
  string str2 = " worldworldworld";

  // 전부 붙이기
  str1.append(str2); // "hello worldworldworld"

  // str2(param1)의 시작위치(param2)부터 원하는갯수(param3)만큼 붙이기
  str1.append(str2, 0, 6); // "hello world"

  // 원하는갯수(param1)만큼 원하는 문자를 붙이기(param2)
  str1.append(5, '.'); // "hello....."
  ```

##### size & length
  ```c
  str.size();
  str.length();
  ```

##### compare
  ```c
  // =========================== string 타입 문자열 ========================= //
  string str1 = "aaa";
  string str2 = "aab";

  // <, >, == : 앞에서부터 아스키코드 기준 비교
  if(str1 == str2) // True, False
    cout << "True" << '\n';

  int ret = str1.compare(str2); // 같으면 0, 다르면 -1/1 : return (str1-str2)


  // =========================== C 타입 문자열 ========================= //
  // 맨 뒤에 '\n' 존재하는 문자열에서만 사용 가능
  // c_str의 경우, == 연산자 사용시, 주소값을 비교하게됨
  char s1[10] = "aaa";
  char s2[10] = "aab";

  int ret1 = strcmp(s1, s2); // 같으면 0, 다르면 -1/1 : return (s1-s2)
  int ret2 = strncmp(s3, s1, 2); // 원하는갯수(param3) 만큼 같은지 확인 : return (s1-s2)
  ```

##### find
  ```c
  string str1 = "hello world ! I love you lovelove";
  string str2 = "love";

  str1.find(str2); // 16
  str1.find("nothing"); // string::npos

  // 원하는 문자열(param1)을 지정한 위치(param2) 이후부터 찾기
  int pos = str1.find(str2);  // 16
  str.find(str2, pos + 1);    // 25

  // 거꾸로 탐색
  str1.rfind("love"); // 29

  // ============================== Example ============================ //
  // 같은 문자열이 여러번 나타날때 유용
  size_t pos;
  string str = "hello world ! I love you lovelove";
  pos = tr.find("love");

  while(pos != string::pos){
    // cout << pos << " "; // "love"의 위치출력
    pos = str.find("love", pos + 1);
  }

  // =========================== C 타입 문자열 ========================= //
  char s1[] = "HelloMWorld";
  char* ptr = strchr(s1, 'W');
  if (ptr != NULL) {
    cout << *ptr << endl;	// W
    cout << ptr << endl;	// World
    cout << &ptr << endl;	// 주소
  }

  char s1[] = "HelloMWorld";
  cout << strchr(s1, 'W') << '\n'; // World
  ```
  > 리턴값 strchr() 함수는 string의 문자로 변환되는 c의 첫 번째 표시에 대한 포인터를 리턴. 함수는 지정된 문자를 찾지 못하면 NULL을 리턴.
  > 따라서 strchr은 value가 아닌 주소값 포인터이므로 * 포인터로 지정가능

##### substr
  ```c
  // 원하는 위치만큼 sub-string 부분문자열을 만들 수 있음
  string str1 = "good morning Mr Brown";
  string str2;
  str2 = str1.substr(5, 7); // "morning"
  str2 = str1.substr(5);    // "morning Mr Brown"
  str2 = str1.substr(str1.find("Mr")); // "Mr Brown"
  ```
  - `str1.substr(5)` : index가 5번째인 값부터 끝까지 문자열을 반환
  - `str1.substr(5,1)` : index가 5번째인 값부터 1 길이의 문자열을 반환

##### replace
  ```c
  strgin str = "hello my world";

  // param1 이상, param2 미만의 sub-string을 param3으로 대체
  str.replace(str.find("my"), 2, "your"); // hello your world // [6, (6+2))
  str.replace(str.begin()+6, str.begin()+8, "hello"); // hello hello world // [6, 8)

  str.replace(6, 3, "HELLO WORLD", 0, 3); // 6, 0: 각각의 시작위치 // 3: 길이
  str.replace(6, 3, "HELLO WORLD", 2);    // "HELLO WORLD"의 처음 2글자로 대체

  ```
  - `str1.replace(5, 2, str2)` : str1의 5번째인 자리부터 2개의 문자열을 str2문자열 전체로 대체

##### swap, reverse
  ```c
  swap(str1, str2)                  // str1와 str2의 참조를 서로 바꾸어줌 // str1<=>str2
  reverse(str.begin(), str.end());  // 문자열 역순 반환
  ```

##### erase
  ```c
  str.assign("12345678");

  // 시작위치(param1)부터 지정한갯수(param2)만큼 삭제
  str.erase(0, 4);  // 5678
  str.erase(4, 4);  // 1234
  str.erase(4, 1);  // 1234678 // ind=4 위치, value=5 삭제

  // 시작위치(param1)~끝까지 삭제
  str.erase(4);     // 1234
  str.erase();      // 전체삭제
  ```

##### empty & clear
  ```c
  // 문자열에 내용이 있으면 문자열 초기화
  if (str.empty() == 0)
    str.clear();
  ```

> 접근: at(), operator[], front(), back(), push_back(), pop_back(), begin(), end()  
크기: size(), length(), capacity(), resize(), shrink_to_fit(), reserve(), clear(), empty()  
형변환, 비교, 찾기: c_str(), compare(), copy(), find()  
수정: swap(), operator+,  replace(), substr()  

---

# Vector
`#include <vector>`: vector를 사용하기 위한 헤더

##### 선언
  ```c
  vector<int> v;          // 비어있는 vector v를 생성

  vector<int> v(n);       // default 값(0)으로 초기화 된 n개의 원소를 가지는 vector v를 생성
  vector<int> v(n, val);  // val로 초기화된 n개의 원소를 가지는 vector v를 생성
  vector<int> v1(5, 2);   // 2, 2, 2, 2, 2

  vector<int> v2(v1);     // v2는 v1 vector를 복사해서 생성
  ```

##### 원소 할당, 접근
  ```c
  // ============================== 할당 ============================ //
  v.assign(5, 2); // 2의 값으로 5개의 원소 할당
  // v.reserve(n);   // n개의 원소를 저장할 위치를 예약(미리 동적할당)

  // ========================== 삽입, 삭제 ========================== //
  v.push_back(7); // 마지막 원소 뒤에 원소 7을 삽입
  v.pop_back();   // 마지막 원소를 제거

  v.insert(2, 3, 4); // 2번째 위치에 3개의 4값을 삽입 (뒤 원소들은 뒤로 밀림)
  v.insert(2, 3); // v[2] = 3 와 같음
  // 2번째 위치에 3의 값을 삽입
  // 삽입한 곳의 iterator를 반환

  v.erase(iter);
  // iter 가 가리키는 원소를 제거
  // size만 줄어들고 capacity(할당된 메모리)는 그대로 남음

  // ============================== 크기 ============================ //
  v.size(); // 원소의 갯수를 리턴
  // v.capacity();  // 할당된 공간의 크기를 리턴
  // v.resize(n);   // 크기를 n으로 변경 (더 커졌을 경우 default값인 0으로 초기화)

  // ============================== 접근 ============================ //
  v.at(idx); // idx번째 원소를 리턴
  v[idx]; // idx 번째 원소를 리턴 // 범위를 점검X, 속도가 v.at(idx)보다 빠름

  v.front(); // 첫번째 원소를 리턴
  v.back(); // 마지막 원소를 리턴

  /* iterator */
  v.begin();  // 첫번째 원소를 가리 // (iterator와 사용)
  v.end();    // 마지막의 "다음"을 가리킴 (iterator와 사용)
  v.rbegin(); // reverse begin을 가리킴 (거꾸로 해서 첫번째 원소를 가리킴, iterator와 사용)
  v.rend();   // reverse end 을 가리킴 (거꾸로 해서 마지막의 다음을 가리킴, iterator와 사용)

  // =========================== 제거, 비었는지 ========================= //
  v.empty() //  vector가 비었으면 리턴 true
  // 비어있다의 기준은 size가 0이라는 것이지, capacity와는 상관이 없음

  v.clear();
  // 모든 원소를 제거합니다.
  // 원소만 제거하고 메모리는 남아있음
  // size만 줄어들고 capacity는 그대로 남아있음

  // =============================== ETC ============================= //
  // swap
  v2.swap(v1);    // v1과 v2의 원소와 capacity 바꿈 (모든걸 스왑해줌)

  // copy
  copy(v1.begin(), v1.end(), v2.begin()); // src: v1  // dst: v2

  if (v1 == v2) // v1과 v2의 원소가 모두 같은가?
  if (v1 != v2) // v1과 v2의 원소 중 하나라도 다른 것이 있는가?
  ```

##### iterator 사용
  ```c
  vector<int>::iterator iter;
  for(iter = v.begin(); iter != v.end() ; iter++){
      cout << *iter << " ";
  }
  ```

##### copy
  - for문이 copy보다 느림
  ```c
  // 1차원 벡터 복사
  copy(v1.begin(), v1.end(), v2.begin()); // src: v1  // dst: v2

  // 다차원 벡터 복사
  v2.resize(v1.size(), vector<int>(v1.size()));
  copy(v1.begin(), v1.end(), v2.begin());
  ```

  - <details>
    <summary>배열 복사</summary>
    <div markdown="1">

    ```c
    /* 1차원 배열 복사 */
    copy(arr1, arr1 + ARR_SIZE, arr2);
    // param1: 배열의 시작부분
    // param2: 배열의 끝부분
    // param3: 복사할 배열의 시작부분을 각각 포인터로 넘겨준다.

    /* 2차원 배열 복사 */
    copy(&arr1[0][0], &arr1[0][0] + ARR_SIZE * ARR_SIZE, &arr2[0][0]);
    ```

    </div>
    </details>  

##### swap
  ```C
  v2.swap(v1);    // v1과 v2의 원소와 capacity 바꿈 (모든걸 스왑해줌)
  ```

---

# 정렬
방법: 2개(sort 함수 사용, 인덱스로 접근하여 배열 활용)

##### sort 함수
  - 퀵소트 사용: O(nlogn)
  - 언제 사용?
    - 입력 형식이 복잡한 형식일 때 유용
    - 값의 수가 적을 때 유용
    - 정렬 조건을 까다롭게 정의해야하는 경우 유용 (compare 함수 정의해서 해결가능)

  ```c
    #include <algorithm>          // sort 함수 사용을 위해 필요

    sort(arr, arr+10);            // [arr, arr+10) default(오름차순) 정렬
    sort(v.begin(), v.end());                    // default: 오름차순
    sort(v.begin(), v.end(), greater<int>());    //내림차순
    sort(v.begin(), v.end(), less<int>());       //오름차순

    sort(v.begin(), v.end(), compare);           //사용자 정의 함수 사용
  ```
  ```c
    // compare 함수 정의
    bool compare(int a, int b){
      if (a < b) return true; // 오름차순 정렬
      else return false;
    }
  ```
  > **compare 함수에서 return 값이 의미하는 것**  
  파라미터 순서가 *(int a, int b)*인 경우,   
  `return a<b;`   *오름차순*  
  `return true;`  *a와 b의 위치를 그대로 두기*  
  `return false;` *a와 b의 위치를 바꾸어야 원하는 sort 완성가능*  

  <details>
  <summary>연산자 오버로딩(operator overloading, '<') 활용한 sort</summary>
  <div markdown="1">

  ```c
    class Student{
      public:
        string name;
        int age;
        Student(string name, int age):name(name),age(age){}

        // 연산자 오버로딩
        bool operator<(Student s) const{  
            if(this->name == s.name){
                return this->age < s.age;
            }else{
                return this->name < s.name;
            }
        }
    };

    // 출력형식 지정
    void Print(vector<Student> &v){
      for(int i=0; i<5; i++){
          cout << v[i].name << ", " << v[i].age << '\n';
      }
      cout << endl;
    }

    // 정렬 호출
    sort(v.begin(), v.end());   // [begin, end) 연산자 오버로딩 이용한 정렬

    Print(v);                   // 정렬 후 출력
  ```
  </div>
  </details>  

##### 배열 활용
  - 언제 사용?
    - 정렬하고자하는 값이 단순한 값일 경우(int, char)
    - 값의 범위가 작을 때 유용
    - 메모리 제한이 빡셀때 유용
  - 방법
    1. 주어진 범위만큼 배열을 선언
    2. **받은 값을 인덱스 삼아** 배열에 ++
    3. for문으로 앞에서부터 배열을 탐색하면 정렬된 것처럼 사용할 수 있음

##### Example
  <details>
  <summary>정렬된 경우, 최빈원소(가장 많이 나타나는 원소) 찾기</summary>
  <div markdown="1">

  ```c
    vector<int> v(n);
    for(auto& i : v)
      cin >> i;

    sort(v.begin(), v.end());

    int res = v[0];
    int res_cnt = 1, tmp = 1;
    for(int i = 1; i < n; i++){
      if(v[i] == v[i-1]) tmp++;     // 이전 원소와 같으면 tmp++
      else tmp = 1;                 // 이전 원소와 다르면 1로 초기화

      if (res_cnt < tmp) {          // 매번! 조건 확인 후에
        res_cnt = tmp;              // 원소 하나 확인 후, 바로 바로 max값 갱신
        res = v[i];
      }
    }
  ```
  </div>
  </details>  

---

# Queue, PQ, Heap

##### Queue
  - rear(end)에 데이터를 삽입하고 front에서 데이터를 빼는 자료구조
  - 선입선출
  - 큐의 종류
    1. 선형 큐
    2. 환형 큐
    3. 우선순위 큐([Priority Queue](Priority-Queue))
  - 함수
  ```c
  #include <queue>

  queue<int> q;

  q.push(1);
  q.pop();

  q.push(1); q.push(2); q.push(3);
  q.front();  // 1
  q.back();   // 3

  q.size();   // 3

  while(!q.empty()){ // q 안의 모든 원소를 제거
    q.pop();
  }
  // q.clear() 존재하지 않음
  // 큐가 비었는데 pop하려하면 에러 발생
  ```

##### Priority Queue
  - 최대, 최소 값을 빠르게 찾기 위해서 사용
  - **Heap**으로 구현 가능
  > Heap
    + 완전이진트리의 일종
    + Heap Tree는 중복을 허용 (이진탐색트리에서는 중복 비허용)
    + 우선순위 큐를 구현하는 방법 중에 가장 효율적
    + 삽입, 삭제 모두 O(logn)
    + 배열을 사용하여 구현 (index 0번은 쉬운 계산을 위해 사용하지 않음)
    + 특정 위치의 노드번호는 새로운 노드가 추가되어도 변하지 않음

  - 부모, 자식 관계
    + 부모의 인덱스 = n
    + 왼쪽자식의 인덱스 = 2n
    + 오른쪽자식의 인덱스 = 2n+1
    > *부모의 인덱스(n) = 자식의 인덱스(2n, 2n+1) / 2*

  - **삽입** 시, 맨 마지막 노드에 삽입하고 상위 노드와 값을 비교하여 위치를 변경해감
  - **삭제** 시, 최상위 루트 노드를 삭제하고, 그 자리에 최하단 마지막 노드를 가져옴  
     이후 하위 노드와 값을 비교하여 위치를 변경해감
  - 삽입, 삭제가 이루어질 때마다 위치 업데이트 실시  
    최대로 노드 위치 업데이트 해봤자 *트리의 높이 이하* 만큼의 업데이트 진행

  - **종류**
    - max heap: 내림차순 *(default)*  
      root 노드에는 (우선순위가) 가장 큰 값이 들어있음   // -,4,3,2,1
    - min heap: 오름차순  
      root 노드에는 (우선순위가) 가장 작은 값이 들어있음 // -,1,2,3,4

  ```c
  // ============================== 선언 =================================
  #include <queue>

  priority_queue<int> pq;     // default: max heap (내림차순)
  priority_queue<int, vector<int>, greater<int>> pq; // min heap (오름차순)

  //사용자 지정 비교함수 사용
  priority_queue<int, vector<int>, compare> pq;
  ```
  ```c
  // ============ comp structure와 operator overloading ==================
  struct compare {
      bool operator()(const int& a, const int& b) {
          // method 1
          return a > b;  // 오름차순

          // method 2
          if(a > b) return true; // 오름차순
          else return false;
      }
  };

  struct compare {
      bool operator()(int a, int b) {
          return l > r;  // 오름차순
      }
  };
  ```
  > **compare 함수의 return 값이 의미하는 것**  
   `return true;`  : b의 우선순위를 더 높게 만들기  
   `return false;` : a의 우선순위를 더 높게 만들기  

  ```c
  // =================== 함수 ======================
  pq.size();
  pq.push();
  pq.pop();
  pq.top();
  pq.empty()
  ```

---

# Stack
  - 한쪽에서만 자료를 넣고 뺄 수 있는 자료구조
  - LIFO (Last-in First-out)
  - 활용: 문자열 뒤집기, 괄호검사, 후위표기식 계산, 중위표기식을 후위표기식으로 변환
  ```c
  #include <stack>

  stack<int> st;

  st.push(2);
  st.pop();

  st.push(1); st.push(2); st.push(3);
  st.top();   // 3
  st.size();  // 3

  while(!st.empty()) {  // st 안의 모든 원소를 제거
    st.pop();
  }
  // st.clear() 존재하지 않음
  // 스택이 비었는데 pop하려하면 에러 발생
  ```

> stack은 세로로 길고(위에서 접근), queue는 가로로 길기(옆/앞에서 접근) 때문에 가장 우선원소에 접근하는 함수명이 다르다  
이 외에 다른 함수는 대부분 비슷  
`stack.top()` vs. `q.front()`

---

---

# Deque
  - 양쪽에서 삽입 삭제 가능
  - 크기가 가변적
  - 앞, 뒤에서 삽입/삭제 가능
  - 중간에 데이터 삽입/삭제가 용이하지 않음
  - 랜덤접근(인덱스로 접근) 가능 *(= 리스트처럼 탐색하지 않아도 된다)*
  - 많은 데이터 혹은 검색량이 많은 경우, *map, set, hash_map* 사용하는 것이 좋음

##### 생성
  ```c
  #include <deque>

  deque<int> dq;             // dq는 빈 컨테이너
  deque<int> dq(n);          // dq는 default 값으로 초기화 된 n개의 원소를 가짐
  deque<int> dq(n, val);     // dq는 val로 초기화 된 n개의 원소를 가짐
  deque<int> dq(dq2);        // dq는 dq2의 복사본
  deque<int> dq(begin, end); // dq는 반복자 구간 [begin, end)로 초기화 된 원소를 가짐
  ```

##### 함수
  ```c
  // ============================== 할당, 접근 =================================
  dq.assign(10, "Hello");   // 특정원소로 덱을 채움, param2가 주어지지 않으면 default형으로 채워짐
  dq.assign(4, 3);          // 3의 값으로 4개의 원소 할당 // 3,3,3,3

  dq.at(idx);   // idx번째 원소를 반환, 유효범위를 점검, dq[idx]보다 속도가 느림
  dq[idx];      // idx 번째 원소를 참조

  dq.front();   // 첫 번째 원소를 참조
  dq.back();    // 맨 마지막 원소를 참조

  // ============================== 삽입, 삭제 =================================
  dq.push_front(3); // dq의 첫 번째 원소 앞에 원소 3을 삽입
  dq.pop_front();   // dq의 첫 번째 원소를 제거

  dq.push_back(5);    // dq의 마지막 원소 뒤에 원소 5를 삽입
  dq.pop_back();      // 마지막 원소를 제거

  dq.insert(1, 2, 3);
  // 1번째 위치에 2개의 3값을 삽입
  // 삽입 시에 앞뒤 원소의 개수를 판단하여 적은 쪽으로 미루어서 삽입
  // 만약 앞의 원소의 개수가 적을 경우, 앞쪽으로 블록을 만들어서 원소를 옮기고 삽입
  // 만약 뒤의 원소의 개수가 적을 경우, 뒤쪽으로 블록을 만들어서 원소를 옮기고 삽입

  dq.insert(3, 4);
  // 3번째 위치에 4의 값을 삽입
  // 삽입한 곳의 iterator를 반환

  // ============================== 크기 =================================
  dq.size();    // 원소의 개수를 리턴

  dq.resize(n);
  // 크기를 n 으로 변경
  // 만약 크기가 더 커졌을 경우 비어있는 원소를 default값인 0으로 초기화
  dq.resize(n,2);
  // 크기를 n 으로 변경
  // 만약 크기가 더 커졌을 경우 빈 원소를 2로 초기화

  // capacity 함수는 없음

  // ============================== ETC =================================
  dq2.swap(dq1); // dq1과 dq2를 바꿈 (swap)

  dq.empty()    // dq가 비었으면 true를 반환
  dq.clear();   // 모든 원소를 제거

  dq.erase(iter);
  // iter가 가리키는 원소를 제거
  // 제거 한 후 앞 뒤의 원소의 개수를 판단하여 적은쪽의 원소를 당겨서 채움
  // 제거한 곳의 iterator 를 반환
  ```

##### iterator

  <details>
  <summary>반복자 종류 (begin, end)</summary>
  <div markdown="1">

  ```c
  dq.begin();
  // 첫번째 원소를 가리킴 (iterator와 사용)
  // ex) deque<int>::iterator iter = dq.begin();

  dq.end();
  // 마지막의 "다음"을 가리킴 (iterator와 사용)
  // ex) deque<int>::iterator iter = dq.end();

  dq.rbegin();
  // reverse begin을 가리킴
  // 맨 마지막원소를 마치 첫 번째 원소처럼 가리킴 (역으로)
  // iterator와 사용
  // ex) deque<int>::iterator iter = dq.rbegin();

  dq.rend();
  //  reverse end 을 가리킴
  // 맨 첫번째 원소의 "앞"을 마지막 원소의 "다음" 처럼 가리킴
  // iterator와 사용
  // ex) deque<int>::iterator iter = dq.rend();
  ```

  </div>
  </details>  

  ```c
  // ============================== 정방향 출력 =================================
  deque<int>::iterator iter;

  for(iter = dq.begin(); iter != dq.end() ; iter++){
    cout << *iter << '\n';
  }

  // ============================== 역방향 출력 =================================
  deque<int>::reverse_iterator r_iter;

  for(r_iter = dq.rbegin(); r_iter != dq.rend() ; r_iter++) {
     cout << *r_iter << '\n';
  }
  ```

---
